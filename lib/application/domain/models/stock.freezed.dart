// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'stock.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$StockDataTearOff {
  const _$StockDataTearOff();

  _StockData call(String symbol, String companyName,
      {String primaryExchange,
      String calculationPrice,
      double open,
      DateTime openTime,
      String openSource,
      double high,
      DateTime highTime,
      String highSource,
      double low,
      DateTime lowTime,
      String lowSource,
      double latestPrice,
      String latestSource,
      String latestTime,
      DateTime latestUpdate,
      int latestVolume}) {
    return _StockData(
      symbol,
      companyName,
      primaryExchange: primaryExchange,
      calculationPrice: calculationPrice,
      open: open,
      openTime: openTime,
      openSource: openSource,
      high: high,
      highTime: highTime,
      highSource: highSource,
      low: low,
      lowTime: lowTime,
      lowSource: lowSource,
      latestPrice: latestPrice,
      latestSource: latestSource,
      latestTime: latestTime,
      latestUpdate: latestUpdate,
      latestVolume: latestVolume,
    );
  }
}

// ignore: unused_element
const $StockData = _$StockDataTearOff();

mixin _$StockData {
  String get symbol;
  String get companyName;
  String get primaryExchange;
  String get calculationPrice;
  double get open;
  DateTime get openTime;
  String get openSource;
  double get high;
  DateTime get highTime;
  String get highSource;
  double get low;
  DateTime get lowTime;
  String get lowSource;
  double get latestPrice;
  String get latestSource;
  String get latestTime;
  DateTime get latestUpdate;
  int get latestVolume;

  $StockDataCopyWith<StockData> get copyWith;
}

abstract class $StockDataCopyWith<$Res> {
  factory $StockDataCopyWith(StockData value, $Res Function(StockData) then) =
      _$StockDataCopyWithImpl<$Res>;
  $Res call(
      {String symbol,
      String companyName,
      String primaryExchange,
      String calculationPrice,
      double open,
      DateTime openTime,
      String openSource,
      double high,
      DateTime highTime,
      String highSource,
      double low,
      DateTime lowTime,
      String lowSource,
      double latestPrice,
      String latestSource,
      String latestTime,
      DateTime latestUpdate,
      int latestVolume});
}

class _$StockDataCopyWithImpl<$Res> implements $StockDataCopyWith<$Res> {
  _$StockDataCopyWithImpl(this._value, this._then);

  final StockData _value;
  // ignore: unused_field
  final $Res Function(StockData) _then;

  @override
  $Res call({
    Object symbol = freezed,
    Object companyName = freezed,
    Object primaryExchange = freezed,
    Object calculationPrice = freezed,
    Object open = freezed,
    Object openTime = freezed,
    Object openSource = freezed,
    Object high = freezed,
    Object highTime = freezed,
    Object highSource = freezed,
    Object low = freezed,
    Object lowTime = freezed,
    Object lowSource = freezed,
    Object latestPrice = freezed,
    Object latestSource = freezed,
    Object latestTime = freezed,
    Object latestUpdate = freezed,
    Object latestVolume = freezed,
  }) {
    return _then(_value.copyWith(
      symbol: symbol == freezed ? _value.symbol : symbol as String,
      companyName:
          companyName == freezed ? _value.companyName : companyName as String,
      primaryExchange: primaryExchange == freezed
          ? _value.primaryExchange
          : primaryExchange as String,
      calculationPrice: calculationPrice == freezed
          ? _value.calculationPrice
          : calculationPrice as String,
      open: open == freezed ? _value.open : open as double,
      openTime: openTime == freezed ? _value.openTime : openTime as DateTime,
      openSource:
          openSource == freezed ? _value.openSource : openSource as String,
      high: high == freezed ? _value.high : high as double,
      highTime: highTime == freezed ? _value.highTime : highTime as DateTime,
      highSource:
          highSource == freezed ? _value.highSource : highSource as String,
      low: low == freezed ? _value.low : low as double,
      lowTime: lowTime == freezed ? _value.lowTime : lowTime as DateTime,
      lowSource: lowSource == freezed ? _value.lowSource : lowSource as String,
      latestPrice:
          latestPrice == freezed ? _value.latestPrice : latestPrice as double,
      latestSource: latestSource == freezed
          ? _value.latestSource
          : latestSource as String,
      latestTime:
          latestTime == freezed ? _value.latestTime : latestTime as String,
      latestUpdate: latestUpdate == freezed
          ? _value.latestUpdate
          : latestUpdate as DateTime,
      latestVolume:
          latestVolume == freezed ? _value.latestVolume : latestVolume as int,
    ));
  }
}

abstract class _$StockDataCopyWith<$Res> implements $StockDataCopyWith<$Res> {
  factory _$StockDataCopyWith(
          _StockData value, $Res Function(_StockData) then) =
      __$StockDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {String symbol,
      String companyName,
      String primaryExchange,
      String calculationPrice,
      double open,
      DateTime openTime,
      String openSource,
      double high,
      DateTime highTime,
      String highSource,
      double low,
      DateTime lowTime,
      String lowSource,
      double latestPrice,
      String latestSource,
      String latestTime,
      DateTime latestUpdate,
      int latestVolume});
}

class __$StockDataCopyWithImpl<$Res> extends _$StockDataCopyWithImpl<$Res>
    implements _$StockDataCopyWith<$Res> {
  __$StockDataCopyWithImpl(_StockData _value, $Res Function(_StockData) _then)
      : super(_value, (v) => _then(v as _StockData));

  @override
  _StockData get _value => super._value as _StockData;

  @override
  $Res call({
    Object symbol = freezed,
    Object companyName = freezed,
    Object primaryExchange = freezed,
    Object calculationPrice = freezed,
    Object open = freezed,
    Object openTime = freezed,
    Object openSource = freezed,
    Object high = freezed,
    Object highTime = freezed,
    Object highSource = freezed,
    Object low = freezed,
    Object lowTime = freezed,
    Object lowSource = freezed,
    Object latestPrice = freezed,
    Object latestSource = freezed,
    Object latestTime = freezed,
    Object latestUpdate = freezed,
    Object latestVolume = freezed,
  }) {
    return _then(_StockData(
      symbol == freezed ? _value.symbol : symbol as String,
      companyName == freezed ? _value.companyName : companyName as String,
      primaryExchange: primaryExchange == freezed
          ? _value.primaryExchange
          : primaryExchange as String,
      calculationPrice: calculationPrice == freezed
          ? _value.calculationPrice
          : calculationPrice as String,
      open: open == freezed ? _value.open : open as double,
      openTime: openTime == freezed ? _value.openTime : openTime as DateTime,
      openSource:
          openSource == freezed ? _value.openSource : openSource as String,
      high: high == freezed ? _value.high : high as double,
      highTime: highTime == freezed ? _value.highTime : highTime as DateTime,
      highSource:
          highSource == freezed ? _value.highSource : highSource as String,
      low: low == freezed ? _value.low : low as double,
      lowTime: lowTime == freezed ? _value.lowTime : lowTime as DateTime,
      lowSource: lowSource == freezed ? _value.lowSource : lowSource as String,
      latestPrice:
          latestPrice == freezed ? _value.latestPrice : latestPrice as double,
      latestSource: latestSource == freezed
          ? _value.latestSource
          : latestSource as String,
      latestTime:
          latestTime == freezed ? _value.latestTime : latestTime as String,
      latestUpdate: latestUpdate == freezed
          ? _value.latestUpdate
          : latestUpdate as DateTime,
      latestVolume:
          latestVolume == freezed ? _value.latestVolume : latestVolume as int,
    ));
  }
}

class _$_StockData with DiagnosticableTreeMixin implements _StockData {
  const _$_StockData(this.symbol, this.companyName,
      {this.primaryExchange,
      this.calculationPrice,
      this.open,
      this.openTime,
      this.openSource,
      this.high,
      this.highTime,
      this.highSource,
      this.low,
      this.lowTime,
      this.lowSource,
      this.latestPrice,
      this.latestSource,
      this.latestTime,
      this.latestUpdate,
      this.latestVolume})
      : assert(symbol != null),
        assert(companyName != null);

  @override
  final String symbol;
  @override
  final String companyName;
  @override
  final String primaryExchange;
  @override
  final String calculationPrice;
  @override
  final double open;
  @override
  final DateTime openTime;
  @override
  final String openSource;
  @override
  final double high;
  @override
  final DateTime highTime;
  @override
  final String highSource;
  @override
  final double low;
  @override
  final DateTime lowTime;
  @override
  final String lowSource;
  @override
  final double latestPrice;
  @override
  final String latestSource;
  @override
  final String latestTime;
  @override
  final DateTime latestUpdate;
  @override
  final int latestVolume;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StockData(symbol: $symbol, companyName: $companyName, primaryExchange: $primaryExchange, calculationPrice: $calculationPrice, open: $open, openTime: $openTime, openSource: $openSource, high: $high, highTime: $highTime, highSource: $highSource, low: $low, lowTime: $lowTime, lowSource: $lowSource, latestPrice: $latestPrice, latestSource: $latestSource, latestTime: $latestTime, latestUpdate: $latestUpdate, latestVolume: $latestVolume)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'StockData'))
      ..add(DiagnosticsProperty('symbol', symbol))
      ..add(DiagnosticsProperty('companyName', companyName))
      ..add(DiagnosticsProperty('primaryExchange', primaryExchange))
      ..add(DiagnosticsProperty('calculationPrice', calculationPrice))
      ..add(DiagnosticsProperty('open', open))
      ..add(DiagnosticsProperty('openTime', openTime))
      ..add(DiagnosticsProperty('openSource', openSource))
      ..add(DiagnosticsProperty('high', high))
      ..add(DiagnosticsProperty('highTime', highTime))
      ..add(DiagnosticsProperty('highSource', highSource))
      ..add(DiagnosticsProperty('low', low))
      ..add(DiagnosticsProperty('lowTime', lowTime))
      ..add(DiagnosticsProperty('lowSource', lowSource))
      ..add(DiagnosticsProperty('latestPrice', latestPrice))
      ..add(DiagnosticsProperty('latestSource', latestSource))
      ..add(DiagnosticsProperty('latestTime', latestTime))
      ..add(DiagnosticsProperty('latestUpdate', latestUpdate))
      ..add(DiagnosticsProperty('latestVolume', latestVolume));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _StockData &&
            (identical(other.symbol, symbol) ||
                const DeepCollectionEquality().equals(other.symbol, symbol)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)) &&
            (identical(other.primaryExchange, primaryExchange) ||
                const DeepCollectionEquality()
                    .equals(other.primaryExchange, primaryExchange)) &&
            (identical(other.calculationPrice, calculationPrice) ||
                const DeepCollectionEquality()
                    .equals(other.calculationPrice, calculationPrice)) &&
            (identical(other.open, open) ||
                const DeepCollectionEquality().equals(other.open, open)) &&
            (identical(other.openTime, openTime) ||
                const DeepCollectionEquality()
                    .equals(other.openTime, openTime)) &&
            (identical(other.openSource, openSource) ||
                const DeepCollectionEquality()
                    .equals(other.openSource, openSource)) &&
            (identical(other.high, high) ||
                const DeepCollectionEquality().equals(other.high, high)) &&
            (identical(other.highTime, highTime) ||
                const DeepCollectionEquality()
                    .equals(other.highTime, highTime)) &&
            (identical(other.highSource, highSource) ||
                const DeepCollectionEquality()
                    .equals(other.highSource, highSource)) &&
            (identical(other.low, low) ||
                const DeepCollectionEquality().equals(other.low, low)) &&
            (identical(other.lowTime, lowTime) ||
                const DeepCollectionEquality()
                    .equals(other.lowTime, lowTime)) &&
            (identical(other.lowSource, lowSource) ||
                const DeepCollectionEquality()
                    .equals(other.lowSource, lowSource)) &&
            (identical(other.latestPrice, latestPrice) ||
                const DeepCollectionEquality()
                    .equals(other.latestPrice, latestPrice)) &&
            (identical(other.latestSource, latestSource) ||
                const DeepCollectionEquality()
                    .equals(other.latestSource, latestSource)) &&
            (identical(other.latestTime, latestTime) ||
                const DeepCollectionEquality()
                    .equals(other.latestTime, latestTime)) &&
            (identical(other.latestUpdate, latestUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.latestUpdate, latestUpdate)) &&
            (identical(other.latestVolume, latestVolume) ||
                const DeepCollectionEquality()
                    .equals(other.latestVolume, latestVolume)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(symbol) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(primaryExchange) ^
      const DeepCollectionEquality().hash(calculationPrice) ^
      const DeepCollectionEquality().hash(open) ^
      const DeepCollectionEquality().hash(openTime) ^
      const DeepCollectionEquality().hash(openSource) ^
      const DeepCollectionEquality().hash(high) ^
      const DeepCollectionEquality().hash(highTime) ^
      const DeepCollectionEquality().hash(highSource) ^
      const DeepCollectionEquality().hash(low) ^
      const DeepCollectionEquality().hash(lowTime) ^
      const DeepCollectionEquality().hash(lowSource) ^
      const DeepCollectionEquality().hash(latestPrice) ^
      const DeepCollectionEquality().hash(latestSource) ^
      const DeepCollectionEquality().hash(latestTime) ^
      const DeepCollectionEquality().hash(latestUpdate) ^
      const DeepCollectionEquality().hash(latestVolume);

  @override
  _$StockDataCopyWith<_StockData> get copyWith =>
      __$StockDataCopyWithImpl<_StockData>(this, _$identity);
}

abstract class _StockData implements StockData {
  const factory _StockData(String symbol, String companyName,
      {String primaryExchange,
      String calculationPrice,
      double open,
      DateTime openTime,
      String openSource,
      double high,
      DateTime highTime,
      String highSource,
      double low,
      DateTime lowTime,
      String lowSource,
      double latestPrice,
      String latestSource,
      String latestTime,
      DateTime latestUpdate,
      int latestVolume}) = _$_StockData;

  @override
  String get symbol;
  @override
  String get companyName;
  @override
  String get primaryExchange;
  @override
  String get calculationPrice;
  @override
  double get open;
  @override
  DateTime get openTime;
  @override
  String get openSource;
  @override
  double get high;
  @override
  DateTime get highTime;
  @override
  String get highSource;
  @override
  double get low;
  @override
  DateTime get lowTime;
  @override
  String get lowSource;
  @override
  double get latestPrice;
  @override
  String get latestSource;
  @override
  String get latestTime;
  @override
  DateTime get latestUpdate;
  @override
  int get latestVolume;
  @override
  _$StockDataCopyWith<_StockData> get copyWith;
}
